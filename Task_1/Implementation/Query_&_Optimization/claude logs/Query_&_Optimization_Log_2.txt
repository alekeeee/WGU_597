================================================================================
HEALTH TRACKER DATABASE - INDEX ANALYSIS & OPTIMIZATION SESSION
================================================================================

Generated: 2026-02-03
Database: health_tracker (PostgreSQL 16)
Topic: Index Utilization, EXPLAIN ANALYZE, and Healthcare Analytics Use Cases


================================================================================

┌──────────────────────────────────────────────────────────────────────────────┐
│ EXCHANGE 1                                                                   │
└──────────────────────────────────────────────────────────────────────────────┘

► USER PROMPT:
────────────────────────────────────────
Connect to health_tracker database and look into the indexs created under the
obseration table

◄ CLAUDE RESPONSE:
────────────────────────────────────────
The `observation` table has 4 indexes:

| Index Name               | Type            | Column(s)                      |
|--------------------------|-----------------|--------------------------------|
| observation_pkey         | PRIMARY KEY     | observation_id                 |
| idx_obs_datetime         | btree           | date_time                      |
| idx_obs_metric           | btree           | metric_id                      |
| idx_obs_user_metric_time | btree           | user_id, metric_id, date_time  |

The composite index `idx_obs_user_metric_time` is well-designed for common query
patterns like "get all readings for a specific user and metric within a time
range" — which is typical for fitness tracker dashboards.


┌──────────────────────────────────────────────────────────────────────────────┐
│ EXCHANGE 2                                                                   │
└──────────────────────────────────────────────────────────────────────────────┘

► USER PROMPT:
────────────────────────────────────────
How do indexs work? Say for example the script:

```sql
SELECT
    u.user_id,
    ui.first_name,
    ui.last_name,
    o.value AS sleep_score,
    o.date_time
FROM observation o
JOIN "User" u ON o.user_id = u.user_id
JOIN user_info ui ON u.user_id = ui.user_id
WHERE o.metric_id = 43  -- sleep_score
  AND o.date_time >= NOW() - INTERVAL '24 hours'
  AND o.value < 60
ORDER BY o.value ASC
```

since there is no index with this specific column combination, does it pull
from the indexes with only a single column?

◄ CLAUDE RESPONSE:
────────────────────────────────────────

## How Index Selection Works

**B-tree indexes work left-to-right.** For a composite index like
`idx_obs_user_metric_time (user_id, metric_id, date_time)`:
- It can efficiently filter if you provide `user_id` first
- Since your query doesn't filter on `user_id`, this composite index is less
  useful here

**PostgreSQL can combine single-column indexes** using **Bitmap Index Scans**:
1. Scan `idx_obs_metric` → find rows where `metric_id = 43` → create a bitmap
2. Scan `idx_obs_datetime` → find rows in last 24 hours → create another bitmap
3. AND the bitmaps together
4. Fetch only matching rows, then filter on `value < 60`

EXPLAIN ANALYZE output:

```
Index Scan using idx_obs_user_metric_time on observation o
  Index Cond: ((user_id = u.user_id) AND (metric_id = 43) AND (date_time >= ...))
  Filter: (value < '60'::numeric)
```

**The strategy:**
1. First, it joins `User` and `user_info` tables (Hash Join)
2. For **each user**, it uses the composite index with all 3 columns:
   - `user_id` comes from the JOIN (not the WHERE clause!)
   - `metric_id = 43` from WHERE
   - `date_time >= ...` from WHERE
3. Then filters `value < 60` on the fetched rows

## Key Takeaways

| Concept              | Explanation                                              |
|----------------------|----------------------------------------------------------|
| Left-to-right rule   | Composite indexes require leading columns, but they can  |
|                      | come from JOINs, not just WHERE                          |
| Bitmap combining     | PostgreSQL *can* AND multiple single-column indexes      |
|                      | together, but it chose not to here                       |
| Filter vs Index Cond | `value < 60` appears as "Filter" (checked after fetch)   |
|                      | since there's no index on `value`                        |


┌──────────────────────────────────────────────────────────────────────────────┐
│ EXCHANGE 3                                                                   │
└──────────────────────────────────────────────────────────────────────────────┘

► USER PROMPT:
────────────────────────────────────────
Is there a way I can temporarily disable the indexs so I can analyze the
execution time without the indexs?

◄ CLAUDE RESPONSE:
────────────────────────────────────────
Yes, you can disable index scans at the session level without dropping them:

```sql
-- Disable index scans for this session
SET enable_indexscan = off;
SET enable_bitmapscan = off;
SET enable_indexonlyscan = off;

EXPLAIN ANALYZE
SELECT ...;

-- Re-enable (or just disconnect)
SET enable_indexscan = on;
SET enable_bitmapscan = on;
SET enable_indexonlyscan = on;
```

## Comparison Results

| Metric              | With Indexes   | Without Indexes              |
|---------------------|----------------|------------------------------|
| Execution Time      | 220 ms         | 156,072 ms (~2.6 minutes)    |
| Observation Scan    | Index Scan     | Parallel Seq Scan            |
| Rows Scanned        | Targeted       | 334 million rows filtered    |

Without indexes, PostgreSQL had to:
- Sequentially scan the entire observation table (~1 billion rows)
- Filter out 334,417,668 rows per worker
- Then join the results

These settings only affect your current session — they reset when you
disconnect, so your indexes remain intact.


┌──────────────────────────────────────────────────────────────────────────────┐
│ EXCHANGE 4                                                                   │
└──────────────────────────────────────────────────────────────────────────────┘

► USER PROMPT:
────────────────────────────────────────
Did this disable the primary key indexs or just the ones i created?

◄ CLAUDE RESPONSE:
────────────────────────────────────────
Those settings disabled **all index scans**, including primary key indexes.

**With indexes enabled:**
```
Parallel Index Only Scan using "User_pkey" on "User" u
```

**With indexes disabled:**
```
Seq Scan on "User" u
Seq Scan on user_info ui
Parallel Seq Scan on observation o
```

The `enable_indexscan`, `enable_bitmapscan`, and `enable_indexonlyscan` settings
affect the **query planner's behavior**, not specific indexes. PostgreSQL
doesn't distinguish between primary key indexes and ones you created — they're
all just B-tree indexes internally.

To test disabling only specific indexes while keeping primary keys:

```sql
BEGIN;
DROP INDEX idx_obs_user_metric_time;
EXPLAIN ANALYZE SELECT ...;
ROLLBACK;  -- index is restored
```


┌──────────────────────────────────────────────────────────────────────────────┐
│ EXCHANGE 5                                                                   │
└──────────────────────────────────────────────────────────────────────────────┘

► USER PROMPT:
────────────────────────────────────────
Create a script that I can run that disables the indexs i created for the
observation table and then runs an explain analyze, then recreates the index
so future queries are not affected

◄ CLAUDE RESPONSE:
────────────────────────────────────────
Created `test_without_indexes.sql`:

```sql
-- Script to test query performance without custom indexes on observation table
-- Primary key index (observation_pkey) is preserved

\echo '========================================'
\echo 'Dropping custom indexes on observation...'
\echo '========================================'

DROP INDEX IF EXISTS idx_obs_datetime;
DROP INDEX IF EXISTS idx_obs_metric;
DROP INDEX IF EXISTS idx_obs_user_metric_time;

\echo 'Running EXPLAIN ANALYZE without indexes...'

EXPLAIN ANALYZE
SELECT
    u.user_id,
    ui.first_name,
    ui.last_name,
    o.value AS sleep_score,
    o.date_time
FROM observation o
JOIN "User" u ON o.user_id = u.user_id
JOIN user_info ui ON u.user_id = ui.user_id
WHERE o.metric_id = 43
  AND o.date_time >= NOW() - INTERVAL '24 hours'
  AND o.value < 60
ORDER BY o.value ASC;

\echo 'Recreating indexes...'

CREATE INDEX idx_obs_datetime ON observation(date_time);
CREATE INDEX idx_obs_metric ON observation(metric_id);
CREATE INDEX idx_obs_user_metric_time ON observation(user_id, metric_id, date_time);

\di *observation*
```

Run with:
```bash
psql -d health_tracker -f "test_without_indexes.sql"
```


┌──────────────────────────────────────────────────────────────────────────────┐
│ EXCHANGE 6                                                                   │
└──────────────────────────────────────────────────────────────────────────────┘

► USER PROMPT:
────────────────────────────────────────
What does the \echo do?

◄ CLAUDE RESPONSE:
────────────────────────────────────────
`\echo` is a psql meta-command that prints text to the console. It's like
`echo` in bash but for psql scripts.

```sql
\echo 'Dropping indexes...'
```

Outputs:
```
Dropping indexes...
```

It's purely for display — it helps you see progress when running the script.

Other useful psql meta-commands:

| Command      | Purpose                          |
|--------------|----------------------------------|
| \echo        | Print message                    |
| \timing      | Toggle query execution time      |
| \di          | List indexes                     |
| \dt          | List tables                      |
| \d tablename | Describe table structure         |
| \q           | Quit psql                        |


┌──────────────────────────────────────────────────────────────────────────────┐
│ EXCHANGE 7                                                                   │
└──────────────────────────────────────────────────────────────────────────────┘

► USER PROMPT:
────────────────────────────────────────
When i attempt to run it in harlequin's query editor i get error
"syntax error at or near "\"

◄ CLAUDE RESPONSE:
────────────────────────────────────────
`\echo` and other backslash commands are **psql-specific** — they don't work
in other SQL clients like Harlequin.

Run the script via terminal with:

```bash
psql -d health_tracker -f "/path/to/test_without_indexes.sql"
```

Or if you're already in psql:

```
\i '/path/to/test_without_indexes.sql'
```


┌──────────────────────────────────────────────────────────────────────────────┐
│ EXCHANGE 8                                                                   │
└──────────────────────────────────────────────────────────────────────────────┘

► USER PROMPT:
────────────────────────────────────────
How do you run the index creations in concurrency?

◄ CLAUDE RESPONSE:
────────────────────────────────────────

## 1. `CREATE INDEX CONCURRENTLY` — Non-blocking index creation

Builds the index without locking the table for writes:

```sql
CREATE INDEX CONCURRENTLY idx_obs_datetime ON observation(date_time);
```

**Limitation:** Cannot run inside a transaction block.

## 2. Parallel index builds — Multiple indexes at once

To create multiple indexes simultaneously, you need **separate connections**:

```bash
psql -d health_tracker -c "CREATE INDEX CONCURRENTLY idx_obs_datetime ON observation(date_time);" &
psql -d health_tracker -c "CREATE INDEX CONCURRENTLY idx_obs_metric ON observation(metric_id);" &
psql -d health_tracker -c "CREATE INDEX CONCURRENTLY idx_obs_user_metric_time ON observation(user_id, metric_id, date_time);" &
wait
```

The `&` runs each command in the background, and `wait` pauses until all finish.

Created comprehensive guide: `concurrent_index_guide.md`


┌──────────────────────────────────────────────────────────────────────────────┐
│ EXCHANGE 9                                                                   │
└──────────────────────────────────────────────────────────────────────────────┘

► USER PROMPT:
────────────────────────────────────────
Look at the indexs of observation and consider the use cases of these in
optimizing personalized healthcare analytics. Give an explanation of the use
cases and explain why you created the composite key as well as the singular
metric_id and date_time index. i.e. why not just the composite?

◄ CLAUDE RESPONSE:
────────────────────────────────────────

## The Core Problem: B-tree Indexes Work Left-to-Right

The composite index `(user_id, metric_id, date_time)` can only be used
efficiently when the query includes columns **from the left side first**:

| Query Filters                                    | Can Use Composite? |
|--------------------------------------------------|--------------------|
| user_id = X                                      | Yes                |
| user_id = X AND metric_id = Y                    | Yes                |
| user_id = X AND metric_id = Y AND date_time >= Z | Yes (full index)   |
| metric_id = Y                                    | No (skips user_id) |
| date_time >= Z                                   | No (skips columns) |

## Healthcare Analytics Use Cases

### 1. Patient-Centric Queries → Uses Composite Index

```sql
-- "Show me John's heart rate for the past week"
SELECT date_time, value
FROM observation
WHERE user_id = 12345
  AND metric_id = 7  -- heart_rate
  AND date_time >= NOW() - INTERVAL '7 days';
```

**Why composite works:** Query starts with `user_id`.

### 2. Population Health / Cohort Analysis → Needs `idx_obs_metric`

```sql
-- "Find all patients with critically low oxygen levels"
SELECT DISTINCT user_id
FROM observation
WHERE metric_id = 15  -- blood_oxygen
  AND value < 90
  AND date_time >= NOW() - INTERVAL '24 hours';
```

**Why composite fails:** No `user_id` filter — searching all patients.

### 3. Real-Time Monitoring & Alerting → Needs `idx_obs_datetime`

```sql
-- "Get all observations from the last 5 minutes"
SELECT o.*, u.user_id
FROM observation o
JOIN "User" u ON o.user_id = u.user_id
WHERE o.date_time >= NOW() - INTERVAL '5 minutes';
```

**Why composite fails:** No `user_id` or `metric_id` filter.

## Summary

| Index                    | Primary Use Case                        |
|--------------------------|-----------------------------------------|
| idx_obs_user_metric_time | Patient dashboards, individual care     |
| idx_obs_metric           | Population health, research, cohorts    |
| idx_obs_datetime         | Real-time monitoring, alerting, audits  |


┌──────────────────────────────────────────────────────────────────────────────┐
│ EXCHANGE 10                                                                  │
└──────────────────────────────────────────────────────────────────────────────┘

► USER PROMPT:
────────────────────────────────────────
Lets say you have critical health metrics where you want to collect rows that
are deemed critical to warn a specific user or even just collect data for
analytics, why would indexing only on the metric as opposed to the composite
index be better?

◄ CLAUDE RESPONSE:
────────────────────────────────────────

## The Query Pattern

For critical health alerts: **"Find all users with dangerous readings"**

```sql
SELECT user_id, value, date_time
FROM observation
WHERE metric_id = 15      -- blood_oxygen
  AND value < 90          -- critical threshold
  AND date_time >= NOW() - INTERVAL '10 minutes';
```

## Why Composite Index Fails

The composite index is sorted as `(user_id, metric_id, date_time)`:

```
user_id=1, metric_id=15, date_time=...
user_id=2, metric_id=15, date_time=...
user_id=3, metric_id=15, date_time=...
...
```

To find `metric_id = 15` without specifying `user_id`, PostgreSQL would have to
check each of the 100,000 users separately — **100k index seeks**.

## Why Single-Column Metric Index Works

The `idx_obs_metric` index is sorted by `metric_id` only:

```
metric_id=7,  observation_id=...
metric_id=15, observation_id=...  ← jump directly here
metric_id=15, observation_id=...
metric_id=43, observation_id=...
```

One direct lookup finds **all blood oxygen readings** in a contiguous block.

## Concrete Comparison

| Index Used               | What Happens                      | Efficiency |
|--------------------------|-----------------------------------|------------|
| idx_obs_metric           | Jump to metric_id=15, scan block  | Fast       |
| idx_obs_user_metric_time | 100k separate index lookups       | Slow       |
| No index                 | Scan entire 1B row table          | Slowest    |

## Summary

The composite index answers: **"What did patient X experience?"**
The metric index answers: **"Who is experiencing condition Y?"**


┌──────────────────────────────────────────────────────────────────────────────┐
│ EXCHANGE 11                                                                  │
└──────────────────────────────────────────────────────────────────────────────┘

► USER PROMPT:
────────────────────────────────────────
Look at the 3 scripts in the folder 'database management' and explain how each
script utilizes these indexes

◄ CLAUDE RESPONSE:
────────────────────────────────────────

## Script 1: `sleepQuality_script.rtf`

```sql
SELECT u.user_id, ui.first_name, ui.last_name, o.value AS sleep_score, o.date_time
FROM observation o
JOIN "User" u ON o.user_id = u.user_id
JOIN user_info ui ON u.user_id = ui.user_id
WHERE o.metric_id = 43 AND o.date_time >= NOW() - INTERVAL '24 hours' AND o.value < 60
ORDER BY o.value ASC
```

**Index Usage:** `idx_obs_user_metric_time` (composite) via JOIN

**Why:** JOIN provides `user_id`, enabling full composite index usage.

---

## Script 2: `sleepStages_script.rtf`

```sql
SELECT o.user_id,
    MAX(CASE WHEN o.metric_id = 65 THEN o.value END) AS rem_minutes,
    MAX(CASE WHEN o.metric_id = 66 THEN o.value END) AS light_minutes,
    MAX(CASE WHEN o.metric_id = 67 THEN o.value END) AS deep_minutes,
    MAX(CASE WHEN o.metric_id = 40 THEN o.value END) AS total_duration,
    MAX(CASE WHEN o.metric_id = 43 THEN o.value END) AS sleep_score
FROM observation o
WHERE o.metric_id IN (65, 66, 67, 40, 43)
  AND o.date_time >= NOW() - INTERVAL '24 hours'
GROUP BY o.user_id
```

**Index Usage:** `idx_obs_metric` + `idx_obs_datetime` (Bitmap AND)

**Why:** No JOIN on User table, no `user_id` in WHERE. Population-level query.

---

## Script 3: `sleepTrend_script.rtf`

```sql
SELECT user_id, DATE(date_time) AS night,
    ROUND(AVG(value)::numeric, 1) AS avg_sleep_score,
    ROUND(AVG(AVG(value)) OVER (
        PARTITION BY user_id ORDER BY DATE(date_time)
        ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
    )::numeric, 1) AS rolling_7day_avg
FROM observation
WHERE metric_id = 43 AND date_time >= NOW() - INTERVAL '14 days'
GROUP BY user_id, DATE(date_time)
```

**Index Usage:** `idx_obs_metric` + `idx_obs_datetime` (Bitmap AND)

**Why:** No `user_id` in WHERE — population trend analysis.

---

## Summary Table

| Script         | Query Type              | Indexes Used          | Why Not Composite?     |
|----------------|-------------------------|-----------------------|------------------------|
| sleepQuality   | Patient lookup + JOINs  | Composite (via JOIN)  | It IS used             |
| sleepStages    | Population aggregation  | Metric + DateTime     | No user_id filter/JOIN |
| sleepTrend     | Population trend        | Metric + DateTime     | No user_id filter/JOIN |


┌──────────────────────────────────────────────────────────────────────────────┐
│ EXCHANGE 12                                                                  │
└──────────────────────────────────────────────────────────────────────────────┘

► USER PROMPT:
────────────────────────────────────────
Take a look at sleepAnomoly.sql. How does this utilize the indexes?

◄ CLAUDE RESPONSE:
────────────────────────────────────────

## `sleepAnomoly.sql` — Index Analysis

```sql
WITH user_baseline AS (
    SELECT user_id, AVG(value) AS avg_score, STDDEV(value) AS std_score
    FROM observation
    WHERE metric_id = 43 AND date_time >= NOW() - INTERVAL '30 days'
    GROUP BY user_id
),
last_night AS (
    SELECT DISTINCT ON (user_id) user_id, value AS last_score, date_time
    FROM observation
    WHERE metric_id = 43 AND date_time >= NOW() - INTERVAL '24 hours'
    ORDER BY user_id, date_time DESC
)
SELECT ln.user_id, ln.last_night_score, ub.baseline_avg, z_score
FROM last_night ln
JOIN user_baseline ub ON ln.user_id = ub.user_id
WHERE ABS(ln.last_score - ub.avg_score) > 2 * ub.std_score;
```

## Index Usage by CTE

| Query Part     | Indexes Used                      | Purpose                    |
|----------------|-----------------------------------|----------------------------|
| user_baseline  | idx_obs_metric + idx_obs_datetime | Get 30-day avg/stddev      |
| last_night     | idx_obs_metric + idx_obs_datetime | Get most recent sleep score|
| Final JOIN     | None (small result sets)          | Compare and flag anomalies |

## Why Composite Index Can't Help

Both CTEs filter only on `metric_id` and `date_time` — no `user_id` in WHERE.

This is a **proactive alerting query** — scanning all users to find anomalies.
You don't know which users have anomalies until you run it.


┌──────────────────────────────────────────────────────────────────────────────┐
│ EXCHANGE 13                                                                  │
└──────────────────────────────────────────────────────────────────────────────┘

► USER PROMPT:
────────────────────────────────────────
What is the usecase of calculating baseline for all users if this is for
personalized analytics?

◄ CLAUDE RESPONSE:
────────────────────────────────────────

## Two Different Patterns

| Pattern                 | Query Style     | When It Runs            | Index Used    |
|-------------------------|-----------------|-------------------------|---------------|
| Batch Alerting          | Scan all users  | Scheduled (e.g., 6 AM)  | Single-column |
| On-Demand Personalized  | Check one user  | When user opens app     | Composite     |

## What `sleepAnomoly.sql` Actually Is

This is a **batch alerting job** — runs proactively to identify who needs
intervention:

- Push notification: "Your sleep was unusually poor last night"
- Clinician dashboard: "These 47 patients need follow-up"
- Care team alert: "Flag these users for outreach"

The **detection is population-wide**, but the **response is personalized**.

## True On-Demand Personalized Query

When a specific user opens their app:

```sql
WITH my_baseline AS (
    SELECT AVG(value) AS avg_score, STDDEV(value) AS std_score
    FROM observation
    WHERE user_id = 12345          -- specific user
      AND metric_id = 43
      AND date_time >= NOW() - INTERVAL '30 days'
)
...
```

**This uses the composite index** — `user_id` is in WHERE.

## Summary

| Scenario         | Question Being Asked         | Best Index     |
|------------------|------------------------------|----------------|
| Batch alert job  | "Which users had anomalies?" | Single-column  |
| User opens app   | "Did I have an anomaly?"     | Composite      |


┌──────────────────────────────────────────────────────────────────────────────┐
│ EXCHANGE 14                                                                  │
└──────────────────────────────────────────────────────────────────────────────┘

► USER PROMPT:
────────────────────────────────────────
Is it proper to say that indexes are important in a vertical structure so that
the workers don't have to do a full table scan?

◄ CLAUDE RESPONSE:
────────────────────────────────────────
Yes, that's valid. Here's why:

## Vertical (EAV) vs Horizontal Structure

**Horizontal (wide table):**
- 1 row per user per timestamp
- 100k users × 365 days = **36.5 million rows**

**Vertical (EAV - what `observation` uses):**
- 1 row per metric per user per timestamp
- 100k users × 365 days × 50 metrics = **1.8 billion rows**

## Why Indexes Are Critical in Vertical Structures

| Factor                           | Impact                                 |
|----------------------------------|----------------------------------------|
| Table size                       | 50× larger than horizontal             |
| Every query filters on metric_id | You almost never want "all metrics"    |
| Without index                    | Full scan of 1.8B rows                 |
| With index                       | Direct seek to ~2% of rows you need    |

Vertical/EAV structures provide **flexibility** at the cost of **table size**.
Indexes offset that cost by making filtered queries efficient.


┌──────────────────────────────────────────────────────────────────────────────┐
│ EXCHANGE 15                                                                  │
└──────────────────────────────────────────────────────────────────────────────┘

► USER PROMPT:
────────────────────────────────────────
What are workers?

◄ CLAUDE RESPONSE:
────────────────────────────────────────
In PostgreSQL, **workers** are parallel processes that split up query execution
to use multiple CPU cores.

From EXPLAIN output:
```
Gather Merge  (cost=...)
   Workers Planned: 2
   Workers Launched: 2
   ->  Parallel Seq Scan on observation o
         Rows Removed by Filter: 334417668   ← each worker filtered ~334M rows
```

## How It Works

| Component          | Role                                    |
|--------------------|-----------------------------------------|
| Leader             | Main process that coordinates the query |
| Workers            | Helper processes that run in parallel   |
| Gather/Gather Merge| Collects results from all workers       |

```
         ┌─────────────┐
         │   Leader    │
         └──────┬──────┘
                │
       ┌────────┼────────┐
       ▼        ▼        ▼
   Worker 1  Worker 2  Worker 3
   (scan     (scan     (scan
   1-333M)   334-666M) 667-1B)
       │        │        │
       └────────┼────────┘
                ▼
         Gather Merge
```

## With vs Without Indexes

| Scenario      | What Workers Do                                  |
|---------------|--------------------------------------------------|
| No index      | Each worker scans portion of full table (334M)   |
| With index    | Index narrows work first, workers process subset |


┌──────────────────────────────────────────────────────────────────────────────┐
│ EXCHANGE 16                                                                  │
└──────────────────────────────────────────────────────────────────────────────┘

► USER PROMPT:
────────────────────────────────────────
Explain to me how real-time analytics will utilize the date_time index instead
of the composite

◄ CLAUDE RESPONSE:
────────────────────────────────────────

## Real-Time Analytics: Why `idx_obs_datetime` Matters

Real-time systems ask: **"What's happening RIGHT NOW?"** — across all users.

## The Query Pattern

```sql
-- Live dashboard: All readings in the last 5 minutes
SELECT user_id, metric_id, value, date_time
FROM observation
WHERE date_time >= NOW() - INTERVAL '5 minutes';

-- Data ingestion monitor
SELECT metric_id, COUNT(*), MAX(date_time) AS latest
FROM observation
WHERE date_time >= NOW() - INTERVAL '1 hour'
GROUP BY metric_id;
```

## Why Composite Index Fails

Sorted as `(user_id, metric_id, date_time)`:
```
(user_id=1, metric_id=7,  date_time=Jan 1)
(user_id=1, metric_id=43, date_time=Jan 1)
(user_id=2, metric_id=7,  date_time=Jan 1)
...
```

Recent data is **scattered across 100k user segments**.

## Why `idx_obs_datetime` Works

Sorted by `date_time` only:
```
(date_time=Feb 3 17:55, observation_id=...)  ← "last 5 min" here
(date_time=Feb 3 17:56, observation_id=...)
(date_time=Feb 3 17:57, observation_id=...)
```

One **contiguous block** at the end of the index.

## Visual Comparison

```
Composite Index:
User 1: [----Jan----Feb----▓▓]  ← recent scattered
User 2: [----Jan----Feb----▓▓]
...100k users...
→ Must check 100k locations

DateTime Index:
[Jan 1][Jan 2]...[Feb 3 17:55][Feb 3 17:56][Feb 3 17:57]
                 └────────── recent data ──────────────┘
→ One contiguous range scan
```

## Summary

| Question                              | Best Index |
|---------------------------------------|------------|
| "What did **user X** do recently?"    | Composite  |
| "What happened in the last 5 minutes?"| DateTime   |


================================================================================
END OF SESSION
================================================================================
